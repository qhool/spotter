import { Track, SpotifyApi } from '@spotify/web-api-ts-sdk';
import { RemovableExportTarget } from './ExportController';

/**
 * GitHub Pages export target that generates a static website
 */
export class GitHubPagesExportTarget implements RemovableExportTarget {
  private tracks: Track[] = [];
  private siteName: string;
  private siteDescription: string;
  private files: Map<string, string> = new Map();

  constructor(options: { siteName: string; siteDescription?: string }) {
    this.siteName = options.siteName;
    this.siteDescription = options.siteDescription || 'Generated by Spotter';
  }

  async initialize(): Promise<void> {
    this.tracks = [];
    this.files.clear();
  }

  async addTracks(tracks: Track[]): Promise<void> {
    this.tracks.push(...tracks);
    this.generateSiteFiles();
  }

  async getCurrentTrackIDs(): Promise<string[]> {
    return this.tracks.map(track => track.id).filter(Boolean) as string[];
  }

  async removeTracks(start: number, end: number | undefined): Promise<void> {
    if (end === undefined) {
      this.tracks.splice(start);
    } else {
      this.tracks.splice(start, end - start);
    }
    this.generateSiteFiles();
  }

  getMaxAddBatchSize(): number {
    return 1000; // Large batch size for in-memory operations
  }

  getOverallDescription(): string {
    return `Exporting to GitHub Pages site "${this.siteName}"`;
  }

  getInitializationDescription(): string {
    return 'Preparing GitHub Pages site';
  }

  private generateSiteFiles(): void {
    // Generate index.html
    this.files.set('index.html', this.generateIndexHtml());
    
    // Generate CSS
    this.files.set('styles.css', this.generateCSS());
    
    // Generate JavaScript
    this.files.set('script.js', this.generateJavaScript());
    
    // Generate tracks data
    this.files.set('tracks.json', this.generateTracksData());
  }

  private generateIndexHtml(): string {
    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${this.escapeHtml(this.siteName)}</title>
    <meta name="description" content="${this.escapeHtml(this.siteDescription)}">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>${this.escapeHtml(this.siteName)}</h1>
            <p class="description">${this.escapeHtml(this.siteDescription)}</p>
            <div class="stats">
                <span id="track-count">${this.tracks.length}</span> tracks
            </div>
        </header>

        <div class="controls">
            <input type="text" id="search" placeholder="Search tracks, artists, or albums...">
            <div class="filters">
                <button class="filter-btn active" data-filter="all">All</button>
                <button class="filter-btn" data-filter="explicit">Explicit</button>
                <button class="filter-btn" data-filter="clean">Clean</button>
            </div>
        </div>

        <div class="track-list" id="track-list">
            <!-- Tracks will be populated by JavaScript -->
        </div>

        <footer class="footer">
            <p>Generated by <a href="https://github.com" target="_blank">Spotter</a> â€¢ ${new Date().toLocaleDateString()}</p>
        </footer>
    </div>

    <script src="script.js"></script>
</body>
</html>`;
  }

  private generateCSS(): string {
    return `/* GitHub Pages Site Styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background-color: #0d1117;
    color: #e6edf3;
    line-height: 1.6;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 2rem;
}

.header {
    text-align: center;
    margin-bottom: 3rem;
    padding-bottom: 2rem;
    border-bottom: 1px solid #30363d;
}

.header h1 {
    font-size: 3rem;
    font-weight: 700;
    background: linear-gradient(45deg, #1db954, #1ed760);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 1rem;
}

.description {
    font-size: 1.2rem;
    color: #8b949e;
    margin-bottom: 1rem;
}

.stats {
    font-size: 1.1rem;
    color: #f0f6fc;
}

.controls {
    display: flex;
    gap: 2rem;
    margin-bottom: 2rem;
    flex-wrap: wrap;
    align-items: center;
}

#search {
    flex: 1;
    min-width: 300px;
    padding: 0.75rem 1rem;
    font-size: 1rem;
    background-color: #21262d;
    border: 1px solid #30363d;
    border-radius: 6px;
    color: #e6edf3;
}

#search:focus {
    outline: none;
    border-color: #1db954;
    box-shadow: 0 0 0 3px rgba(29, 185, 84, 0.1);
}

.filters {
    display: flex;
    gap: 0.5rem;
}

.filter-btn {
    padding: 0.5rem 1rem;
    font-size: 0.9rem;
    background-color: #21262d;
    border: 1px solid #30363d;
    border-radius: 6px;
    color: #e6edf3;
    cursor: pointer;
    transition: all 0.2s ease;
}

.filter-btn:hover {
    background-color: #30363d;
}

.filter-btn.active {
    background-color: #1db954;
    border-color: #1db954;
    color: white;
}

.track-list {
    display: grid;
    gap: 0.5rem;
}

.track-item {
    display: grid;
    grid-template-columns: auto 1fr auto;
    gap: 1rem;
    padding: 1rem;
    background-color: #161b22;
    border: 1px solid #30363d;
    border-radius: 6px;
    transition: all 0.2s ease;
    align-items: center;
}

.track-item:hover {
    background-color: #21262d;
    border-color: #1db954;
}

.track-info {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
    min-width: 0;
}

.track-name {
    font-size: 1rem;
    font-weight: 600;
    color: #f0f6fc;
    text-decoration: none;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.track-name:hover {
    color: #1db954;
}

.track-artist {
    font-size: 0.9rem;
    color: #8b949e;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.track-album {
    font-size: 0.85rem;
    color: #6e7681;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.track-duration {
    font-size: 0.9rem;
    color: #8b949e;
    font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
}

.track-explicit {
    background-color: #6e7681;
    color: white;
    padding: 0.125rem 0.375rem;
    border-radius: 3px;
    font-size: 0.7rem;
    font-weight: 600;
    text-transform: uppercase;
    margin-left: 0.5rem;
}

.footer {
    margin-top: 4rem;
    padding-top: 2rem;
    border-top: 1px solid #30363d;
    text-align: center;
    color: #6e7681;
    font-size: 0.9rem;
}

.footer a {
    color: #1db954;
    text-decoration: none;
}

.footer a:hover {
    text-decoration: underline;
}

.no-results {
    text-align: center;
    padding: 3rem;
    color: #6e7681;
    font-size: 1.1rem;
}

@media (max-width: 768px) {
    .container {
        padding: 1rem;
    }
    
    .header h1 {
        font-size: 2rem;
    }
    
    .controls {
        flex-direction: column;
        align-items: stretch;
    }
    
    #search {
        min-width: auto;
    }
    
    .track-item {
        grid-template-columns: 1fr;
        gap: 0.5rem;
    }
}`;
  }

  private generateJavaScript(): string {
    return `// GitHub Pages Site JavaScript
let allTracks = [];
let filteredTracks = [];

// Load tracks data
async function loadTracks() {
    try {
        const response = await fetch('tracks.json');
        allTracks = await response.json();
        filteredTracks = [...allTracks];
        renderTracks();
        updateStats();
    } catch (error) {
        console.error('Failed to load tracks:', error);
        document.getElementById('track-list').innerHTML = 
            '<div class="no-results">Failed to load tracks</div>';
    }
}

// Format duration from milliseconds to mm:ss
function formatDuration(ms) {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return \`\${minutes}:\${remainingSeconds.toString().padStart(2, '0')}\`;
}

// Escape HTML to prevent XSS
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Render tracks to the DOM
function renderTracks() {
    const trackList = document.getElementById('track-list');
    
    if (filteredTracks.length === 0) {
        trackList.innerHTML = '<div class="no-results">No tracks found</div>';
        return;
    }
    
    trackList.innerHTML = filteredTracks.map(track => {
        const artists = track.artists.map(artist => artist.name).join(', ');
        const album = track.album.name;
        const duration = formatDuration(track.duration_ms);
        const explicitBadge = track.explicit ? 
            '<span class="track-explicit">Explicit</span>' : '';
        
        return \`
            <div class="track-item">
                <div class="track-info">
                    <a href="\${track.external_urls.spotify}" target="_blank" class="track-name">
                        \${escapeHtml(track.name)}\${explicitBadge}
                    </a>
                    <div class="track-artist">\${escapeHtml(artists)}</div>
                    <div class="track-album">\${escapeHtml(album)}</div>
                </div>
                <div class="track-duration">\${duration}</div>
            </div>
        \`;
    }).join('');
}

// Update stats display
function updateStats() {
    document.getElementById('track-count').textContent = filteredTracks.length;
}

// Search functionality
function handleSearch(query) {
    if (!query.trim()) {
        filteredTracks = [...allTracks];
    } else {
        const searchTerm = query.toLowerCase();
        filteredTracks = allTracks.filter(track => {
            const trackName = track.name.toLowerCase();
            const artistNames = track.artists.map(a => a.name.toLowerCase()).join(' ');
            const albumName = track.album.name.toLowerCase();
            
            return trackName.includes(searchTerm) || 
                   artistNames.includes(searchTerm) || 
                   albumName.includes(searchTerm);
        });
    }
    
    renderTracks();
    updateStats();
}

// Filter functionality
function handleFilter(filterType) {
    const baseFilter = document.getElementById('search').value.trim();
    
    // Apply base search filter first
    let tracks = baseFilter ? 
        allTracks.filter(track => {
            const searchTerm = baseFilter.toLowerCase();
            const trackName = track.name.toLowerCase();
            const artistNames = track.artists.map(a => a.name.toLowerCase()).join(' ');
            const albumName = track.album.name.toLowerCase();
            
            return trackName.includes(searchTerm) || 
                   artistNames.includes(searchTerm) || 
                   albumName.includes(searchTerm);
        }) : [...allTracks];
    
    // Apply explicit filter
    switch (filterType) {
        case 'explicit':
            tracks = tracks.filter(track => track.explicit);
            break;
        case 'clean':
            tracks = tracks.filter(track => !track.explicit);
            break;
        case 'all':
        default:
            // No additional filtering
            break;
    }
    
    filteredTracks = tracks;
    renderTracks();
    updateStats();
}

// Initialize event listeners
document.addEventListener('DOMContentLoaded', function() {
    // Load tracks
    loadTracks();
    
    // Search input
    const searchInput = document.getElementById('search');
    searchInput.addEventListener('input', (e) => {
        handleSearch(e.target.value);
        // Reset filter to 'all' when searching
        document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
        document.querySelector('[data-filter="all"]').classList.add('active');
    });
    
    // Filter buttons
    document.querySelectorAll('.filter-btn').forEach(button => {
        button.addEventListener('click', (e) => {
            // Update active state
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            e.target.classList.add('active');
            
            // Apply filter
            handleFilter(e.target.dataset.filter);
        });
    });
});`;
  }

  private generateTracksData(): string {
    // Convert tracks to a simplified format for the web
    const webTracks = this.tracks.map(track => ({
      id: track.id,
      name: track.name,
      artists: track.artists.map(artist => ({ name: artist.name })),
      album: { name: track.album.name },
      duration_ms: track.duration_ms,
      explicit: track.explicit,
      external_urls: track.external_urls,
      popularity: track.popularity
    }));
    
    return JSON.stringify(webTracks, null, 2);
  }

  private escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  /**
   * Get all generated files
   */
  getFiles(): Map<string, string> {
    return new Map(this.files);
  }

  /**
   * Get the generated site data
   */
  getData(): { files: { [key: string]: string }; trackCount: number } {
    const filesObj: { [key: string]: string } = {};
    this.files.forEach((content, filename) => {
      filesObj[filename] = content;
    });
    
    return {
      files: filesObj,
      trackCount: this.tracks.length
    };
  }
}

/**
 * Base class for export targets that store tracks in memory
 */
export abstract class InMemoryExportTarget implements RemovableExportTarget {
  protected tracks: Track[] = [];

  async initialize(): Promise<void> {
    // Base implementation - no initialization needed for in-memory targets
    this.tracks = [];
  }

  async addTracks(tracks: Track[]): Promise<void> {
    this.tracks.push(...tracks);
  }

  async getCurrentTrackIDs(): Promise<string[]> {
    return this.tracks.map(track => track.id).filter(Boolean) as string[];
  }

  async removeTracks(start: number, end: number | undefined): Promise<void> {
    if (end === undefined) {
      // Remove from start to end of array
      this.tracks.splice(start);
    } else {
      // Remove from start to end (exclusive)
      this.tracks.splice(start, end - start);
    }
  }

  getMaxAddBatchSize(): number {
    return 1000; // Large batch size for in-memory operations
  }

  /**
   * Abstract method to get the exported data
   * @returns The tracks in the desired export format
   */
  abstract getData(): any;

  /**
   * Abstract method to get description of the overall export purpose
   */
  abstract getOverallDescription(): string;

  /**
   * Abstract method to get description of the initialization step
   */
  abstract getInitializationDescription(): string;
}

/**
 * Export target that provides tracks as JSON
 */
export class JSONExportTarget extends InMemoryExportTarget {
  getData(): string {
    return JSON.stringify(this.tracks, null, 2);
  }

  getOverallDescription(): string {
    return 'Exporting to JSON format';
  }

  getInitializationDescription(): string {
    return 'Preparing JSON export';
  }
}

/**
 * Export target that manages a Spotify playlist
 */
export class PlaylistExportTarget implements RemovableExportTarget {
  private sdk: SpotifyApi;
  private playlistId: string | null;
  private playlistName?: string;
  private playlistDescription?: string;

  /**
   * Create a PlaylistExportTarget
   * @param sdk Spotify API instance
   * @param options Either { id: string } for existing playlist or { name: string, description?: string } for new playlist
   */
  constructor(sdk: SpotifyApi, options: { id: string } | { name: string; description?: string }) {
    this.sdk = sdk;
    
    if ('id' in options) {
      // Existing playlist
      this.playlistId = options.id;
    } else {
      // New playlist to be created
      this.playlistId = null;
      this.playlistName = options.name;
      this.playlistDescription = options.description || 'Created by Spotter';
    }
  }

  async initialize(): Promise<void> {
    // If we don't have a playlist ID, create a new playlist
    if (!this.playlistId) {
      if (!this.playlistName) {
        throw new Error('No playlist ID or name provided');
      }

      const user = await this.sdk.currentUser.profile();
      const playlist = await this.sdk.playlists.createPlaylist(
        user.id,
        {
          name: this.playlistName,
          description: this.playlistDescription || 'Created by Spotter',
          public: false
        }
      );
      this.playlistId = playlist.id;
    }
  }

  private async ensurePlaylistExists(): Promise<void> {
    // The initialization should have already handled playlist creation
    if (!this.playlistId) {
      throw new Error('Playlist not initialized. Call initialize() first.');
    }
  }

  getOverallDescription(): string {
    if (this.playlistId) {
      return `Exporting to existing playlist (ID: ${this.playlistId})`;
    } else if (this.playlistName) {
      return `Exporting to new playlist "${this.playlistName}"`;
    } else {
      return 'Exporting to playlist';
    }
  }

  getInitializationDescription(): string {
    if (this.playlistId) {
      return 'Verifying playlist access';
    } else {
      return 'Creating playlist';
    }
  }

  async addTracks(tracks: Track[]): Promise<void> {
    await this.ensurePlaylistExists();

    if (tracks.length === 0) return;

    // Add tracks to Spotify playlist (ExportController handles batching)
    const trackUris = tracks.map(track => track.uri);
    await this.sdk.playlists.addItemsToPlaylist(this.playlistId!, trackUris);
  }

  async getCurrentTrackIDs(): Promise<string[]> {
    const tracks = await this.getCurrentTracks();
    return tracks.map(track => track.id).filter(Boolean) as string[];
  }

  async removeTracks(start: number, end: number | undefined): Promise<void> {
    await this.ensurePlaylistExists();

    const currentTracks = await this.getCurrentTracks();
    const endIndex = end ?? currentTracks.length;
    if (start >= currentTracks.length || start >= endIndex) return;

    if (endIndex - start === 0) return;

    // Use Spotify's updatePlaylistItems endpoint to remove range
    // Set range_start, range_length, uris=[] and omit insert_before to remove
    await this.sdk.playlists.updatePlaylistItems(
      this.playlistId!,
      {
        range_start: start,
        range_length: endIndex - start,
        uris: [] // Empty array to remove tracks
        // insert_before is omitted to remove the range
      }
    );
  }

  getMaxAddBatchSize(): number {
    return 10; // Spotify API limit for adding tracks to playlists
  }

  /**
   * Get the playlist ID
   */
  getPlaylistId(): string {
    if (!this.playlistId) {
      throw new Error('Playlist not initialized');
    }
    return this.playlistId;
  }

  /**
   * Get current tracks from Spotify
   */
  async getCurrentTracks(): Promise<Track[]> {
    await this.ensurePlaylistExists();

    // Fetch current playlist tracks from Spotify
    const response = await this.sdk.playlists.getPlaylistItems(
      this.playlistId!,
      'US',
      undefined, // fields
      50, // limit
      0 // offset
    );

    let tracks = response.items
      .filter(item => item.track && item.track.type === 'track')
      .map(item => item.track as Track);

    // If there are more tracks, fetch them all
    let offset = 50;
    while (response.total > offset) {
      const nextResponse = await this.sdk.playlists.getPlaylistItems(
        this.playlistId!,
        'US',
        undefined,
        50,
        offset
      );
      
      const nextTracks = nextResponse.items
        .filter(item => item.track && item.track.type === 'track')
        .map(item => item.track as Track);
      
      tracks.push(...nextTracks);
      offset += 50;
    }

    return tracks;
  }
}
