import { ChangeEvent, useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { ListSelect, XmarkCircle } from 'iconoir-react';
import { SpotifyApi } from '@spotify/web-api-ts-sdk';
import type { Device } from '@spotify/web-api-ts-sdk';
import { RemixContainer } from '../../data/TrackContainer';
import { RemixOptions } from '../../data/RemixFunctions';
import { ExportController, ProgressHandler } from '../../data/ExportController';
import { JSONExportTarget, PlaylistExportTarget, QueueExportTarget } from '../../data/Exporters';
import { ExportProgressOverlay } from '../overlays/ExportProgressOverlay';
import { PlaylistPicker, PlaylistSummary } from '../overlays/PlaylistPicker';
import './ExportPane.css';

export type ExportPaneExportType = 'playlist' | 'json' | 'queue';
type DeviceWithId = Device & { id: string };

interface ExportPaneProps {
  sdk: SpotifyApi;
  remixContainer: RemixContainer<RemixOptions> | null;
  excludedTrackIds: Set<string>;
  initialExportType?: ExportPaneExportType;
  initialPlaylistName?: string;
  initialPlaylistDescription?: string;
  className?: string;
}

export function ExportPane({
  sdk,
  remixContainer,
  excludedTrackIds,
  initialExportType = 'playlist',
  initialPlaylistName = 'Spotter Remix',
  initialPlaylistDescription = 'Generated by Spotter',
  className
}: ExportPaneProps) {
  const [exportType, setExportType] = useState<ExportPaneExportType>(initialExportType);
  const [playlistName, setPlaylistName] = useState(initialPlaylistName);
  const [playlistDescription, setPlaylistDescription] = useState(initialPlaylistDescription);
  const [isExporting, setIsExporting] = useState(false);
  const [filteredTrackCount, setFilteredTrackCount] = useState<number | null>(null);
  const [lastCreatedPlaylistId, setLastCreatedPlaylistId] = useState<string | null>(null);
  const [trackLimit, setTrackLimit] = useState<number | null>(null);
  const [isTrackLimitPopoverOpen, setIsTrackLimitPopoverOpen] = useState(false);
  const [trackLimitDraft, setTrackLimitDraft] = useState<number | null>(null);

  const [availableDevices, setAvailableDevices] = useState<DeviceWithId[]>([]);
  const [selectedDeviceId, setSelectedDeviceId] = useState<string | null>(null);
  const [isLoadingDevices, setIsLoadingDevices] = useState(false);
  const [deviceError, setDeviceError] = useState<string | null>(null);

  const [isPlaylistPickerOpen, setIsPlaylistPickerOpen] = useState(false);
  const [isLoadingPlaylists, setIsLoadingPlaylists] = useState(false);
  const [playlistLoadError, setPlaylistLoadError] = useState<string | null>(null);
  const [playlistOptions, setPlaylistOptions] = useState<PlaylistSummary[]>([]);
  const [selectedExistingPlaylist, setSelectedExistingPlaylist] = useState<PlaylistSummary | null>(null);
  const [playlistSelectionMode, setPlaylistSelectionMode] = useState<'append' | 'replace'>('append');

  const trackLimitControlRef = useRef<HTMLDivElement | null>(null);
  const trackLimitDismissTimeout = useRef<ReturnType<typeof setTimeout> | null>(null);

  const [progressDescription, setProgressDescription] = useState('');
  const [progressCompleted, setProgressCompleted] = useState(0);
  const [progressTracksProcessed, setProgressTracksProcessed] = useState(0);
  const [progressTotalTracks, setProgressTotalTracks] = useState(0);
  const [isCompleted, setIsCompleted] = useState(false);
  const [completionMessage, setCompletionMessage] = useState('');
  const [completionSpotifyId, setCompletionSpotifyId] = useState<string | null>(null);

  const hasRemix = Boolean(remixContainer);
  const selectedQueueDevice = useMemo(() => {
    if (!selectedDeviceId) {
      return null;
    }
    return availableDevices.find(device => device.id === selectedDeviceId) ?? null;
  }, [availableDevices, selectedDeviceId]);

  useEffect(() => {
    let cancelled = false;
    const updateFilteredTrackCount = async () => {
      if (!remixContainer) {
        if (!cancelled) {
          setFilteredTrackCount(null);
        }
        return;
      }

      try {
        const response = await remixContainer.getTracks(-1);
        const count = response.items.filter(track => !excludedTrackIds.has(track.id)).length;
        if (!cancelled) {
          setFilteredTrackCount(count);
        }
      } catch (error) {
        console.error('ExportPane: failed to count filtered tracks', error);
        if (!cancelled) {
          setFilteredTrackCount(null);
        }
      }
    };

    updateFilteredTrackCount();
    return () => {
      cancelled = true;
    };
  }, [remixContainer, excludedTrackIds]);

  useEffect(() => {
    if (filteredTrackCount === null) {
      return;
    }
    setTrackLimit(currentLimit => {
      if (filteredTrackCount < 1) {
        return null;
      }
      if (currentLimit === null) {
        return currentLimit;
      }
      if (currentLimit > filteredTrackCount) {
        return filteredTrackCount;
      }
      return currentLimit;
    });
  }, [filteredTrackCount]);

  useEffect(() => {
    let cancelled = false;

    const loadDevices = async () => {
      setIsLoadingDevices(true);
      setDeviceError(null);
      try {
        const [devicesResponse, playbackState] = await Promise.all([
          sdk.player.getAvailableDevices(),
          sdk.player.getPlaybackState()
        ]);

        if (cancelled) {
          return;
        }

        const devicesWithId = (devicesResponse.devices ?? []).filter(
          (device): device is DeviceWithId => Boolean(device.id)
        );

        setAvailableDevices(devicesWithId);

        if (devicesWithId.length === 0) {
          setSelectedDeviceId(null);
          return;
        }

        const activeDeviceId = playbackState?.device?.id ?? null;
        const fallbackId =
          activeDeviceId && devicesWithId.some(device => device.id === activeDeviceId)
            ? activeDeviceId
            : devicesWithId.find(device => device.is_active)?.id ?? devicesWithId[0]?.id ?? null;

        setSelectedDeviceId(prev => {
          if (prev && devicesWithId.some(device => device.id === prev)) {
            return prev;
          }
          return fallbackId;
        });
      } catch (error) {
        console.error('ExportPane: failed to load Spotify devices', error);
        if (!cancelled) {
          setDeviceError('Unable to load your Spotify devices. Start playback in Spotify and try again.');
          setAvailableDevices([]);
          setSelectedDeviceId(null);
        }
      } finally {
        if (!cancelled) {
          setIsLoadingDevices(false);
        }
      }
    };

    loadDevices();
    return () => {
      cancelled = true;
    };
  }, [sdk]);

  const fetchUserPlaylists = useCallback(async () => {
    setIsLoadingPlaylists(true);
    setPlaylistLoadError(null);
    try {
  const response = await sdk.currentUser.playlists.playlists(50, 0);
      const playlists: PlaylistSummary[] = (response.items ?? []).map(item => ({
        id: item.id,
        name: item.name,
        description: item.description,
        ownerName: item.owner?.display_name ?? item.owner?.id ?? null,
        imageUrl: item.images?.[0]?.url ?? null,
        trackCount: item.tracks?.total ?? undefined
      }));
      setPlaylistOptions(playlists);
    } catch (error) {
      console.error('ExportPane: failed to load playlists', error);
      setPlaylistLoadError('Unable to load your playlists. Please try again.');
    } finally {
      setIsLoadingPlaylists(false);
    }
  }, [sdk]);

  const openPlaylistPicker = useCallback(() => {
    setIsPlaylistPickerOpen(true);
  }, []);

  const closePlaylistPicker = useCallback(() => {
    setIsPlaylistPickerOpen(false);
  }, []);

  useEffect(() => {
    if (!isPlaylistPickerOpen) {
      return;
    }
    if (playlistOptions.length === 0 && !isLoadingPlaylists && !playlistLoadError) {
      fetchUserPlaylists();
    }
  }, [fetchUserPlaylists, isLoadingPlaylists, isPlaylistPickerOpen, playlistLoadError, playlistOptions.length]);

  const clearTrackLimitDismissTimer = useCallback(() => {
    if (trackLimitDismissTimeout.current) {
      window.clearTimeout(trackLimitDismissTimeout.current);
      trackLimitDismissTimeout.current = null;
    }
  }, []);

  const closeTrackLimitPopover = useCallback(() => {
    clearTrackLimitDismissTimer();
    setIsTrackLimitPopoverOpen(false);
    setTrackLimitDraft(null);
  }, [clearTrackLimitDismissTimer]);

  const scheduleTrackLimitDismiss = useCallback(() => {
    clearTrackLimitDismissTimer();
    trackLimitDismissTimeout.current = window.setTimeout(() => {
      closeTrackLimitPopover();
    }, 3000);
  }, [clearTrackLimitDismissTimer, closeTrackLimitPopover]);

  useEffect(() => {
    return () => {
      clearTrackLimitDismissTimer();
    };
  }, [clearTrackLimitDismissTimer]);

  useEffect(() => {
    if (!isTrackLimitPopoverOpen) {
      return;
    }

  const handlePointerDown = (event: PointerEvent) => {
      if (!trackLimitControlRef.current) {
        return;
      }
      if (!trackLimitControlRef.current.contains(event.target as Node)) {
        closeTrackLimitPopover();
      }
    };

    document.addEventListener('pointerdown', handlePointerDown);
    return () => {
      document.removeEventListener('pointerdown', handlePointerDown);
    };
  }, [isTrackLimitPopoverOpen, closeTrackLimitPopover]);

  const handleExportTypeChange = (event: ChangeEvent<HTMLSelectElement>) => {
    setExportType(event.target.value as ExportPaneExportType);
  };

  const handlePlaylistNameChange = (event: ChangeEvent<HTMLInputElement>) => {
    setPlaylistName(event.target.value);
    setLastCreatedPlaylistId(null);
  };

  const handlePlaylistDescriptionChange = (event: ChangeEvent<HTMLTextAreaElement>) => {
    setPlaylistDescription(event.target.value);
  };

  const handleQueueDeviceChange = (event: ChangeEvent<HTMLSelectElement>) => {
    const value = event.target.value;
    setSelectedDeviceId(value ? value : null);
  };

  const handleDismissCompletion = () => {
    setIsCompleted(false);
    setIsExporting(false);
    setCompletionMessage('');
    setCompletionSpotifyId(null);
    setProgressDescription('');
    setProgressCompleted(0);
    setProgressTracksProcessed(0);
    setProgressTotalTracks(0);
  };

  const handleOpenPlaylist = () => {
    if (!lastCreatedPlaylistId) {
      return;
    }
    window.open(`https://open.spotify.com/playlist/${lastCreatedPlaylistId}`, '_blank');
  };

  const getFilteredTracks = useCallback(async () => {
    if (!remixContainer) {
      return [];
    }
    const response = await remixContainer.getTracks(-1);
    const filtered = response.items.filter(track => !excludedTrackIds.has(track.id));
    if (trackLimit === null) {
      return filtered;
    }
    const limit = Math.max(1, Math.min(trackLimit, filtered.length));
    return filtered.slice(0, limit);
  }, [remixContainer, excludedTrackIds, trackLimit]);

  const createProgressHandler = useCallback(
    (totalTracks: number): ProgressHandler => {
      return (description: string, completed: number, numberProcessed: number) => {
        setProgressDescription(description);
        setProgressCompleted(completed);
        setProgressTracksProcessed(numberProcessed);
        setProgressTotalTracks(totalTracks);
      };
    },
    []
  );

  const handleExport = useCallback(async () => {
    if (!remixContainer) {
      return;
    }

    setIsExporting(true);
    try {
      const filteredTracks = await getFilteredTracks();
      const progressHandler = createProgressHandler(filteredTracks.length);

      if (exportType === 'json') {
        const jsonTarget = new JSONExportTarget();
        const controller = new ExportController(jsonTarget, 3, progressHandler);

        await controller.append(filteredTracks);
        const jsonData = await jsonTarget.getData();

        const blob = new Blob([jsonData], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const anchor = document.createElement('a');
        anchor.href = url;
        anchor.download = `${playlistName.replace(/[^a-zA-Z0-9]/g, '_')}.json`;
        document.body.appendChild(anchor);
        anchor.click();
        document.body.removeChild(anchor);
        URL.revokeObjectURL(url);

        setCompletionMessage(`Successfully exported ${filteredTracks.length} tracks to JSON file`);
        setCompletionSpotifyId(null);
        setIsCompleted(true);
      } else if (exportType === 'queue') {
        if (!selectedQueueDevice) {
          alert('Select an active Spotify device before queueing tracks.');
          setIsExporting(false);
          return;
        }

        const queueTarget = new QueueExportTarget(sdk, {
          deviceId: selectedQueueDevice.id,
          deviceName: selectedQueueDevice.name
        });
        const totalQueueTracks = filteredTracks.length;
        const overallDescription = queueTarget.getOverallDescription();

        progressHandler(
          `${overallDescription}: ${queueTarget.getInitializationDescription()}`,
          0,
          0
        );
        await queueTarget.initialize();

        let queuedTracks = 0;
        for (const track of filteredTracks) {
          const nextTrackNumber = queuedTracks + 1;
          const inProgressDescription = `${overallDescription}: Queuing track ${nextTrackNumber}/${totalQueueTracks}`;
          const inProgressCompletion = totalQueueTracks > 0 ? queuedTracks / totalQueueTracks : 0;
          progressHandler(inProgressDescription, inProgressCompletion, queuedTracks);

          await queueTarget.addTracks([track]);

          queuedTracks += 1;
          const afterDescription = `${overallDescription}: Queued track ${queuedTracks}/${totalQueueTracks}`;
          const afterCompletion = totalQueueTracks > 0 ? queuedTracks / totalQueueTracks : 1;
          progressHandler(afterDescription, afterCompletion, queuedTracks);
        }

        progressHandler(`${overallDescription}: Complete`, 1, totalQueueTracks);
        const suffix = filteredTracks.length === 1 ? '' : 's';
        const deviceLabel = selectedQueueDevice.name ?? 'your device';
        setCompletionMessage(`Queued ${filteredTracks.length} track${suffix} on ${deviceLabel}`);
        setCompletionSpotifyId(null);
        setIsCompleted(true);
      } else {
        const usingExistingPlaylist = Boolean(selectedExistingPlaylist);
        const playlistTarget = new PlaylistExportTarget(
          sdk,
          usingExistingPlaylist && selectedExistingPlaylist
            ? { id: selectedExistingPlaylist.id }
            : { name: playlistName, description: playlistDescription }
        );
        const controller = new ExportController(playlistTarget, 5, progressHandler);

        if (usingExistingPlaylist && playlistSelectionMode === 'replace') {
          await controller.replace(filteredTracks);
        } else {
          await controller.append(filteredTracks);
        }

        const playlistId = playlistTarget.getPlaylistId();
        const targetName = usingExistingPlaylist
          ? selectedExistingPlaylist?.name ?? 'playlist'
          : playlistName;
        const trackWord = filteredTracks.length === 1 ? 'track' : 'tracks';

        if (usingExistingPlaylist) {
          if (playlistSelectionMode === 'replace') {
            setCompletionMessage(
              `Replaced all tracks in "${targetName}" with ${filteredTracks.length} ${trackWord}`
            );
          } else {
            setCompletionMessage(`Added ${filteredTracks.length} ${trackWord} to "${targetName}"`);
          }
          setLastCreatedPlaylistId(null);
        } else {
          setCompletionMessage(`Created playlist "${targetName}" with ${filteredTracks.length} ${trackWord}`);
          setLastCreatedPlaylistId(playlistId);
        }

        setCompletionSpotifyId(playlistId);
        setIsCompleted(true);
      }
    } catch (error) {
      console.error('ExportPane: export failed', error);
      let errorMessage = 'Export failed. Please try again.';
      if (error instanceof Error) {
        if (error.message.includes('playlist')) {
          errorMessage = 'Failed to create playlist. Please check your Spotify permissions and try again.';
        } else if (error.message.includes('track')) {
          errorMessage = 'Failed to add tracks to playlist. Some tracks may not be available.';
        } else if (error.message.includes('network') || error.message.includes('fetch')) {
          errorMessage = 'Network error. Please check your internet connection and try again.';
        }
      }
      alert(errorMessage);
      setIsExporting(false);
      setProgressDescription('');
      setProgressCompleted(0);
      setProgressTracksProcessed(0);
      setProgressTotalTracks(0);
    }
  }, [
    createProgressHandler,
    exportType,
    getFilteredTracks,
    playlistDescription,
    playlistName,
    playlistSelectionMode,
    remixContainer,
    sdk,
    selectedExistingPlaylist,
    selectedQueueDevice
  ]);

  const actionButtonLabel = useMemo(() => {
    if (isExporting) {
      return 'Exporting...';
    }
    switch (exportType) {
      case 'json':
        return 'Download JSON';
      case 'queue':
        return 'Queue Tracks';
      case 'playlist':
        if (selectedExistingPlaylist) {
          return playlistSelectionMode === 'replace' ? 'Replace Playlist' : 'Append to Playlist';
        }
        return 'Create Playlist';
      default:
        return 'Create Playlist';
    }
  }, [exportType, isExporting, playlistSelectionMode, selectedExistingPlaylist]);

  const canAdjustTrackLimit = filteredTrackCount !== null && filteredTrackCount > 0;

  const currentTrackLimitValue = useMemo(() => {
    if (filteredTrackCount === null) {
      return null;
    }
    if (isTrackLimitPopoverOpen && trackLimitDraft !== null) {
      return Math.max(1, Math.min(trackLimitDraft, filteredTrackCount));
    }
    if (trackLimit === null) {
      return filteredTrackCount;
    }
    return Math.max(1, Math.min(trackLimit, filteredTrackCount));
  }, [filteredTrackCount, isTrackLimitPopoverOpen, trackLimit, trackLimitDraft]);

  const trackLimitButtonText = useMemo(() => {
    if (filteredTrackCount === null) {
      return 'all tracks';
    }
    if (!currentTrackLimitValue || currentTrackLimitValue >= filteredTrackCount) {
      return `all ${filteredTrackCount}`;
    }
    if (currentTrackLimitValue === 1) {
      return `first of ${filteredTrackCount}`;
    }
    return `first ${currentTrackLimitValue} of ${filteredTrackCount}`;
  }, [currentTrackLimitValue, filteredTrackCount]);


  const effectiveExportCount = useMemo(() => {
    if (filteredTrackCount === null) {
      return null;
    }
    if (trackLimit === null) {
      return filteredTrackCount;
    }
    return Math.max(1, Math.min(trackLimit, filteredTrackCount));
  }, [filteredTrackCount, trackLimit]);

  const disableExportButton =
    !hasRemix ||
    (filteredTrackCount !== null && effectiveExportCount === 0) ||
    (exportType === 'queue' && (!selectedQueueDevice || isLoadingDevices || Boolean(deviceError)));

  const handleTrackLimitButtonClick = useCallback(() => {
    if (!canAdjustTrackLimit) {
      return;
    }
    setIsTrackLimitPopoverOpen(prev => {
      const nextOpen = !prev;
      if (nextOpen) {
        const fallbackTotal = filteredTrackCount ?? 1;
        const baseValue = trackLimit === null ? fallbackTotal : Math.max(1, Math.min(trackLimit, fallbackTotal));
        setTrackLimitDraft(baseValue);
        scheduleTrackLimitDismiss();
      } else {
        setTrackLimitDraft(null);
        clearTrackLimitDismissTimer();
      }
      return nextOpen;
    });
  }, [canAdjustTrackLimit, clearTrackLimitDismissTimer, filteredTrackCount, scheduleTrackLimitDismiss, trackLimit]);

  const handleTrackLimitSliderChange = useCallback(
    (event: ChangeEvent<HTMLInputElement>) => {
      if (filteredTrackCount === null || filteredTrackCount === 0) {
        return;
      }
      const value = Number(event.target.value);
      const clamped = Math.max(1, Math.min(value, filteredTrackCount));
      setTrackLimitDraft(clamped);
      if (clamped >= filteredTrackCount) {
        setTrackLimit(null);
      } else {
        setTrackLimit(clamped);
      }
      scheduleTrackLimitDismiss();
    },
    [filteredTrackCount, scheduleTrackLimitDismiss]
  );

  const handleTrackLimitSliderInteraction = useCallback(() => {
    if (!isTrackLimitPopoverOpen) {
      return;
    }
    scheduleTrackLimitDismiss();
  }, [isTrackLimitPopoverOpen, scheduleTrackLimitDismiss]);

  useEffect(() => {
    if (!isTrackLimitPopoverOpen) {
      return;
    }
    if (canAdjustTrackLimit) {
      return;
    }
    closeTrackLimitPopover();
  }, [canAdjustTrackLimit, closeTrackLimitPopover, isTrackLimitPopoverOpen]);

  const handlePlaylistSelect = useCallback(
    (playlist: PlaylistSummary) => {
      setSelectedExistingPlaylist(playlist);
      setPlaylistSelectionMode('append');
      setIsPlaylistPickerOpen(false);
      setLastCreatedPlaylistId(null);
    },
    []
  );

  const handleClearSelectedPlaylist = useCallback(() => {
    setSelectedExistingPlaylist(null);
    setPlaylistSelectionMode('append');
  }, []);

  const handleTogglePlaylistMode = useCallback(() => {
    setPlaylistSelectionMode(mode => (mode === 'append' ? 'replace' : 'append'));
  }, []);

  const containerClasses = ['export-pane-container'];
  if (className) {
    containerClasses.push(className);
  }

  if (!hasRemix) {
    return (
      <div className={containerClasses.join(' ')}>
        <ExportProgressOverlay
          description={progressDescription}
          completed={progressCompleted}
          tracksProcessed={progressTracksProcessed}
          totalTracks={progressTotalTracks}
          isVisible={isExporting || isCompleted}
          isCompleted={isCompleted}
          completionMessage={completionMessage}
          spotifyPlaylistId={completionSpotifyId ?? undefined}
          onDismiss={handleDismissCompletion}
        />
        <div className="export-pane">
          <div className="no-export">
            <p>Create a remix first to enable export options.</p>
          </div>
        </div>
      </div>
    );
  }

      return (
        <>
          <div className={containerClasses.join(' ')}>
      <ExportProgressOverlay
        description={progressDescription}
        completed={progressCompleted}
        tracksProcessed={progressTracksProcessed}
        totalTracks={progressTotalTracks}
        isVisible={isExporting || isCompleted}
        isCompleted={isCompleted}
        completionMessage={completionMessage}
        spotifyPlaylistId={completionSpotifyId ?? undefined}
        onDismiss={handleDismissCompletion}
      />
      <div className="export-pane">
        <div className="export-options">
          <div className="export-pane__format-row">
            <label className="export-pane__format-label" htmlFor="export-format">
              <span className="export-pane__format-prefix">Export</span>
              <div className="track-limit-control" ref={trackLimitControlRef}>
                <button
                  type="button"
                  className="track-limit-button"
                  disabled={!canAdjustTrackLimit}
                  aria-haspopup="true"
                  aria-expanded={isTrackLimitPopoverOpen}
                  onClick={event => {
                    event.preventDefault();
                    event.stopPropagation();
                    handleTrackLimitButtonClick();
                  }}
                >
                  {trackLimitButtonText}
                </button>
                {isTrackLimitPopoverOpen && filteredTrackCount !== null && filteredTrackCount > 0 && (
                  <div className="track-limit-popover" role="dialog" aria-label="Limit exported tracks">
                    <input
                      type="range"
                      min={1}
                      max={filteredTrackCount}
                      step={1}
                      value={currentTrackLimitValue ?? filteredTrackCount}
                      className="track-limit-slider"
                      onChange={handleTrackLimitSliderChange}
                      onPointerDown={handleTrackLimitSliderInteraction}
                      onPointerUp={handleTrackLimitSliderInteraction}
                      onFocus={handleTrackLimitSliderInteraction}
                      onKeyDown={handleTrackLimitSliderInteraction}
                    />
                  </div>
                )}
              </div>
              <span className="export-pane__format-suffix">to</span>
            </label>
            <select
              id="export-format"
              className="control-select"
              value={exportType}
              onChange={handleExportTypeChange}
            >
              <option value="playlist">Spotify Playlist</option>
              <option value="queue">Spotify Queue</option>
              <option value="json">JSON Export</option>
            </select>
          </div>

          {exportType === 'playlist' && !selectedExistingPlaylist && (
            <>
              <div className="export-group">
                <label className="control-label" htmlFor="playlist-name">
                  Playlist Name
                </label>
                <div className="playlist-name-row">
                  <input
                    id="playlist-name"
                    type="text"
                    className="control-input"
                    value={playlistName}
                    onChange={handlePlaylistNameChange}
                    placeholder="Enter playlist name"
                  />
                  <button
                    type="button"
                    className="icon-button playlist-picker-button"
                    aria-label="Select existing playlist"
                    onClick={openPlaylistPicker}
                  >
                    <ListSelect aria-hidden="true" />
                  </button>
                </div>
              </div>

              <div className="export-group">
                <label className="control-label" htmlFor="playlist-description">
                  Description
                </label>
                <textarea
                  id="playlist-description"
                  className="control-textarea"
                  value={playlistDescription}
                  onChange={handlePlaylistDescriptionChange}
                  placeholder="Enter playlist description"
                  rows={3}
                />
              </div>
            </>
          )}

          {exportType === 'playlist' && selectedExistingPlaylist && (
            <div className="selected-playlist-card">
              <div className="selected-playlist-card__main">
                <div className="selected-playlist-card__thumb">
                  {selectedExistingPlaylist.imageUrl ? (
                    <img src={selectedExistingPlaylist.imageUrl} alt="Playlist cover" />
                  ) : (
                    <div className="selected-playlist-card__thumb-placeholder" aria-hidden="true" />
                  )}
                </div>
                <div className="selected-playlist-card__details">
                  <p className="selected-playlist-card__label">Exporting to existing playlist</p>
                  <h4>{selectedExistingPlaylist.name}</h4>
                  <p className="selected-playlist-card__meta">
                    {selectedExistingPlaylist.ownerName ? `by ${selectedExistingPlaylist.ownerName}` : 'Your playlist'}
                    {selectedExistingPlaylist.trackCount != null && ` • ${selectedExistingPlaylist.trackCount} tracks`}
                  </p>
                </div>
              </div>
              <div className="selected-playlist-card__actions">
                <button
                  type="button"
                  className="playlist-mode-toggle"
                  onClick={handleTogglePlaylistMode}
                >
                  {playlistSelectionMode === 'replace' ? 'Replace' : 'Append'}
                </button>
                <button
                  type="button"
                  className="icon-button"
                  aria-label="Clear playlist selection"
                  onClick={handleClearSelectedPlaylist}
                >
                  <XmarkCircle aria-hidden="true" />
                </button>
              </div>
            </div>
          )}

          {exportType === 'playlist' && lastCreatedPlaylistId && (
            <div className="export-group">
              <label className="control-label" htmlFor="last-created-playlist">
                Last Created Playlist
              </label>
              <div className="playlist-link-container">
                <button
                  id="last-created-playlist"
                  type="button"
                  className="playlist-link-button"
                  onClick={handleOpenPlaylist}
                >
                  Open in Spotify
                </button>
              </div>
            </div>
          )}

          {exportType === 'queue' && (
            <>
              <div className="export-group">
                <label className="control-label" htmlFor="queue-device-select">
                  Choose a Spotify device
                </label>
                {deviceError && <p className="export-feedback export-feedback--error">{deviceError}</p>}
                {!deviceError && !isLoadingDevices && availableDevices.length === 0 && (
                  <p className="export-feedback">No active Spotify devices were found.</p>
                )}
                <select
                  id="queue-device-select"
                  className="control-select"
                  value={selectedDeviceId ?? ''}
                  onChange={handleQueueDeviceChange}
                  disabled={isLoadingDevices || availableDevices.length === 0 || Boolean(deviceError)}
                >
                  <option value="" disabled>
                    {isLoadingDevices ? 'Loading devices…' : 'Select a device'}
                  </option>
                  {availableDevices.map(device => (
                    <option key={device.id} value={device.id}>
                      {device.name}
                      {device.is_active ? ' (active)' : ''}
                    </option>
                  ))}
                </select>
                <p className="export-hint">
                  Start playback in Spotify to refresh the available device list. Only recent active devices can be queued.
                </p>
              </div>
              <div className="export-info">
                <p>
                  Tracks will be appended to the queue of your selected Spotify device. Spotify does not allow removing or reordering
                  queue items via the API, so clear your queue manually if needed before exporting.
                </p>
                <p className="export-info__hint">Start playback on the device you want to queue before running this export.</p>
              </div>
            </>
          )}

          <div className="export-actions">
            <button
              className="export-button primary"
              onClick={handleExport}
              disabled={isExporting || disableExportButton}
            >
              {actionButtonLabel}
            </button>
          </div>
        </div>
      </div>
    </div>

          <PlaylistPicker
            isOpen={isPlaylistPickerOpen}
            isLoading={isLoadingPlaylists}
            error={playlistLoadError}
            playlists={playlistOptions}
            onClose={closePlaylistPicker}
            onRetry={fetchUserPlaylists}
            onSelect={handlePlaylistSelect}
          />
        </>
  );
}
